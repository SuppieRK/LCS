package io.suppie.lcs.ga

import scala.annotation.implicitNotFound
import scala.collection.mutable
import scala.util.Random

class Chromosome[T <: Gene](val code: List[T]) extends Cloneable {
  require(code.nonEmpty, "Chromosome Cannot create a chromosome from undefined genes")

  import Chromosome._

  @volatile var cost: Double = CostFactor * (1.0 + Random.nextDouble)

  @inline final def size: Int = code.size

  @inline final def isEmpty: Boolean = code.isEmpty

  @inline final def fitness: Double = if (cost < Eps) 1e+10 else 1.0 / cost

  def crossover(that: Chromosome[T], indices: GeneticIndices): (Chromosome[T], Chromosome[T]) = {
    require(!that.isEmpty, "Chromosome.+-  Cannot cross-over chromosome with an undefined parent")
    require(this.size == that.size, s"Chromosome.+- Chromosomes $size and that ${that.size} have different size")

    // First use the global index (module the number of gene
    val xoverIdx = indices.chOpIdx
    val xGenes = spliceGene(indices, that.code(xoverIdx))

    // Then recombine the offspring along the cross-over bit
    // Returns the two offsprings that are added to the current population
    (
      Chromosome[T](code.slice(0, xoverIdx) ::: xGenes._1 :: that.code.drop(xoverIdx + 1)),
      Chromosome[T](that.code.slice(0, xoverIdx) ::: xGenes._2 :: code.drop(xoverIdx + 1))
    )
  }

  def mutation(indices: GeneticIndices): Chromosome[T] = {
    // Get the mutation index in the gene to mutate, chOpIdx
    val mutated = code(indices.chOpIdx).mutation(indices)

    // Flip the bit at index 'gIdx.chOpIdx'
    val xs = code.indices.map(i =>
      if (i == indices.chOpIdx) mutated.asInstanceOf[T] else code(i)
    ).toList

    Chromosome[T](xs)
  }

  def normalizeFitness(normalizeFactor: Double): Unit = {
    require(Math.abs(normalizeFactor) > Chromosome.Eps, s"Chromosome./= Cannot normalize with $normalizeFactor > ${Chromosome.Eps}")
    cost /= normalizeFactor
  }

  @implicitNotFound("Chromosome.decode Conversion from Gene to $T is undefined")
  def decode(implicit d: Gene => T): List[T] = code.map(d(_))

  override def clone: Chromosome[T] = Chromosome[T](code)

  override def toString: String = String.valueOf(code.toString())

  def symbolic: String = s"${code.map(_.symbolic).mkString(" ")} cost= $cost fitness: $fitness"

  /**
    * Auxiliary method to splice this chromosome with another
    * chromosome with the genetic material thatCode, along the
    * bit of index gIdx
    */
  private def spliceGene(indices: GeneticIndices, thatCode: T): (T, T) = (
    this.code(indices.chOpIdx).crossover(thatCode, indices).asInstanceOf[T],
    thatCode.crossover(code(indices.chOpIdx), indices).asInstanceOf[T]
  )
}

object Chromosome {
  private val Eps: Double = 1e-10
  val CostFactor: Double = 500.0

  type Pool[T <: Gene] = mutable.ArrayBuffer[Chromosome[T]]

  def apply[T <: Gene](code: List[T]): Chromosome[T] = new Chromosome[T](code)

  def apply[T <: Gene](predicates: List[T], encode: T => Gene): Chromosome[T] = {
    require(predicates.nonEmpty, "Chromosome.apply List of predicates is undefined")

    // Create a chromosome with a single gene for a single predicate
    // or a list of gene for multiple predicate.
    // A gene is actually generated by encoding the predicate
    new Chromosome[T](
      if (predicates.lengthCompare(1) == 0) {
        List[T](encode(predicates.head).asInstanceOf[T])
      } else {
        predicates./:(List[T]())((xs, t) => encode(t).asInstanceOf[T] :: xs)
      }
    )
  }

  def empty[T <: Gene]: Chromosome[T] = new Chromosome[T](List.empty[T])
}
